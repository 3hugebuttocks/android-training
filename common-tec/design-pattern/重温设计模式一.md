### 重温设计模式（一）-- 六大原则和创建型模式
最近打算把设计模式重温一遍，之前看设计模式总有一种雾里看花的感觉，每种模式都大概知道，也可以写几个小 demo，但是真正实践过程中，总是难以运用。后来在读 Android 源码的时候，会从中发现一些设计模式的影子，发现自己的理解会更深刻一些。现在重温设计模式的时候，打算结合具体的源码来进行分析，理解也会更深刻一些。其中会夹带一些“私货”，谈谈个人的一些理解。

### 设计模式六大原则

#### 单一职责原则
单一职责怎么定义的呢？应该有切仅有一个原因引起类的变更。   
更通俗一点来说，就是每个类只负责一件事情。   
其实很好理解，举个栗子，软件工程也相当于一个小社会，对应到我们实际开发团队中，团队中每个人都有自己负责的事情，有问题找到对应的人即可。如果一个人负责全部的事情，出了问题都来找这一个人，难免会很混乱。  
如果再进一步考虑，每个类中的方法，也尽可能负责一件事情，这样代码结果会比较清晰。
当然对于单一职责，往往要根据实际情况，一味的遵守也会带来繁琐。

#### 里氏替换原则
里氏替换的定义是 所有引用基类的地方必须能透明的使用其子类对象。

#### 依赖倒置原则
依赖倒置的关键点是：
1. 高层模块不应该依赖低层模块，两者都应该依赖其抽象
2. 抽象不应该依赖细节
3. 细节应该依赖抽象
通俗的解释就是：
这里的抽象，可以理解为接口或者抽象类。
1. 高层模块可以理解为调用方，低层模块为实现方，高层调用低层，应该通过接口或者抽象类来调用。为什么要这样做呢，通过接口依赖，我们可以很方便的更改实现
2. 接口或抽象类不要依赖于具体的实现
3. 具体的实现应该依赖接口或抽象类
从上面来看，通俗的一句话理解依赖倒置原则就是面向接口编程。用来解耦。

#### 接口隔离原则
接口隔离原则的定义是类之间的依赖关系应该简历再最小的接口上。  
这一原则的含义就是让接口尽量细化，同时接口中的方法尽可能少。

#### 迪米特原则
迪米特原则的定义是：
一个对象应该对其他对象有最少的了解。
通俗的解释就是，调用者只要知道依赖的类公共方法，而方法内部具体的实现是什么样，我不需要去关心。

#### 开闭原则
开闭原则的定义是：
软件中的对象（类，模块，函数等）应该对扩展开放，对修改关闭。
怎么理解呢？就是软件后续的迭代，应该尽可能不去改变原有代码，而是通过扩展接口来实现。因为修改代码往往会带来不可预知的后果。

### 23 种设计模式分类
这里的分类参考 https://www.runoob.com/design-pattern/design-pattern-intro.html
#### 创建型模式
单例模式
工厂模式
抽象工厂模式
建造者模式
原型模式

#### 结构型模式
适配器模式
桥接模式
过滤器模式
组合模式
装饰器模式
外观模式
享元模式
代理模式

#### 行为型模式
责任链模式
命令模式
解释器模式
迭代器模式
中介者模式
备忘录模式
观察者模式
状态模式
空对象模式
策略模式
模板模式
访问者模式

### 创建型模式
#### 单例模式
##### 定义及类图
对于单例模式，我们应该很熟悉了。基本上是代码中必不可少的设计模式了。单例模式是为了保证一个类只有一个实例，并且*自行实例化*并向整个系统提供这个实例。

##### 使用场景
单例模式的场景基本上有两个：
1. 创建多个对象会消耗过多的资源
2. 某种类型的对象数据只能有一份

##### 简单实现
实现重点是确保对象实例的唯一性，而其中有两个注意点：
1. 构造函数私有化
2. 注意多线程情境下的唯一性

单例模式的写法有很多种，下面列举了几种单例的实现方式。
``` java
// 静态变量实现单例
public class Singleton {
    private static Singleton instance = new Singleton();

    private Singleton() {
    }

    public static synchronized Singleton getInstance() {
        return instance;
    }
}

// Double check 实现单例
public class Singleton {
    private static Singleton instance = null;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

// 内部静态类实现单例
public class Singleton {
    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }

    private static class SingletonHolder {
        private static final Singleton instance = new Singleton();
    }
}

// 枚举实现单例
public enum SingletonEnum {
    INSTANCE;
}
```

##### 实例分析
在 Android 系统中，也有很多单例模式。最常见的就是 Context.getSystemService()。
我们在开发中，经常会用到 Context.getSystemService 获取一些系统服务，其实这里就是用了单例模式。我们下面就来看看。
我们调用的方法，会会调用到 ContextImpl.getSystemService 方法，之后从 SYSTEM_SERVICE_FETCHERS 取出缓存的 ServiceFetcher，然后从中取出 Service 实例。
``` java
private static final HashMap<String, ServiceFetcher<?>> SYSTEM_SERVICE_FETCHERS =
        new HashMap<String, ServiceFetcher<?>>();

public static Object getSystemService(ContextImpl ctx, String name) {
    ServiceFetcher<?> fetcher = SYSTEM_SERVICE_FETCHERS.get(name);
    return fetcher != null ? fetcher.getService(ctx) : null;
}
```
而 SYSTEM_SERVICE_FETCHERS 里的实例是在 static 静态块中进行赋值的。
``` java
static {
    // ...
    registerService(Context.ACTIVITY_SERVICE, ActivityManager.class,
            new CachedServiceFetcher<ActivityManager>() {
        @Override
        public ActivityManager createService(ContextImpl ctx) {
            return new ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());
        }});
}
```
单例的实现，就体现在 CachedServiceFetcher 里，看看其 getService 方法。
``` java
public final T getService(ContextImpl ctx) {
    final Object[] cache = ctx.mServiceCache;
    final int[] gates = ctx.mServiceInitializationStateArray;
    for (;;) {
        boolean doInitialize = false;
        synchronized (cache) {
            // 已经创建了 Service 实例
            T service = (T) cache[mCacheIndex];
            if (service != null || gates[mCacheIndex] == ContextImpl.STATE_NOT_FOUND) {
                return service;
            }
            // ...
        }
        try {
            // 创建 Service 实例
            service = createService(ctx);
        } catch (ServiceNotFoundException e) {
        } finally {
            // 保存 Service 实例
            synchronized (cache) {
                cache[mCacheIndex] = service;
                gates[mCacheIndex] = newState;
                cache.notifyAll();
            }
        }
        return service;
    }
}
```
通过上面代码，我们可以看到，如果已经创建了 Service 实例，就使用此实例，否则就去创建实例，从而实现了单例。而其中对多线程唯一性的处理，是通过对 cache 加锁，并修改初始化状态来完成的。

##### 扩展
1. 多进程中的单例模式
我们所说的单例模式，只在当前进程起作用，如果是多进程，就会发现单例失效了。

2. 单例模式为 hook 提供了便利
我们知道，hook 系统实现，最容易的地方就是静态变量，而单例模式往往会提供静态变量来保存对象实例，这就为 hook 系统实现提供了一个很好的切入点。

#### 工厂模式
#### 单例模式
##### 定义及类图
##### 使用场景
##### 简单实现
##### 实例分析
##### 扩展

#### 抽象工厂模式
#### 单例模式
##### 定义及类图
##### 使用场景
##### 简单实现
##### 实例分析
##### 扩展

#### 建造者模式
#### 单例模式
##### 定义及类图
##### 使用场景
##### 简单实现
##### 实例分析
##### 扩展

#### 原型模式
#### 单例模式
##### 定义及类图
##### 使用场景
##### 简单实现
##### 实例分析
##### 扩展

### 写作大纲
#### 单例模式
##### 定义及类图
##### 使用场景
##### 简单实现
##### 实例分析
##### 扩展